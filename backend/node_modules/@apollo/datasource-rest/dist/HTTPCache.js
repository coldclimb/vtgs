"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPCache = void 0;
const node_fetch_1 = __importStar(require("node-fetch"));
const http_cache_semantics_1 = __importDefault(require("http-cache-semantics"));
const utils_keyvaluecache_1 = require("@apollo/utils.keyvaluecache");
class HTTPCache {
    constructor(keyValueCache = new utils_keyvaluecache_1.InMemoryLRUCache(), httpFetch = node_fetch_1.default) {
        this.keyValueCache = new utils_keyvaluecache_1.PrefixingKeyValueCache(keyValueCache, 'httpcache:');
        this.httpFetch = httpFetch;
    }
    async fetch(url, requestOpts = {}, cache) {
        var _a, _b;
        const urlString = url.toString();
        requestOpts.method = (_a = requestOpts.method) !== null && _a !== void 0 ? _a : 'GET';
        const cacheKey = (_b = cache === null || cache === void 0 ? void 0 : cache.cacheKey) !== null && _b !== void 0 ? _b : urlString;
        const entry = await this.keyValueCache.get(cacheKey);
        if (!entry) {
            const response = await this.httpFetch(urlString, requestOpts);
            const policy = new http_cache_semantics_1.default(policyRequestFrom(urlString, requestOpts), policyResponseFrom(response));
            return this.storeResponseAndReturnClone(urlString, response, requestOpts, policy, cacheKey, cache === null || cache === void 0 ? void 0 : cache.cacheOptions);
        }
        const { policy: policyRaw, ttlOverride, body } = JSON.parse(entry);
        const policy = http_cache_semantics_1.default.fromObject(policyRaw);
        policy._url = undefined;
        if ((ttlOverride && policy.age() < ttlOverride) ||
            (!ttlOverride &&
                policy.satisfiesWithoutRevalidation(policyRequestFrom(urlString, requestOpts)))) {
            const headers = policy.responseHeaders();
            return new node_fetch_1.Response(body, {
                url: policy._url,
                status: policy._status,
                headers,
            });
        }
        else {
            const revalidationHeaders = policy.revalidationHeaders(policyRequestFrom(urlString, requestOpts));
            const revalidationRequest = {
                ...requestOpts,
                headers: revalidationHeaders,
            };
            const revalidationResponse = await this.httpFetch(urlString, revalidationRequest);
            const { policy: revalidatedPolicy, modified } = policy.revalidatedPolicy(policyRequestFrom(urlString, revalidationRequest), policyResponseFrom(revalidationResponse));
            return this.storeResponseAndReturnClone(urlString, new node_fetch_1.Response(modified ? await revalidationResponse.text() : body, {
                url: revalidatedPolicy._url,
                status: revalidatedPolicy._status,
                headers: revalidatedPolicy.responseHeaders(),
            }), requestOpts, revalidatedPolicy, cacheKey, cache === null || cache === void 0 ? void 0 : cache.cacheOptions);
        }
    }
    async storeResponseAndReturnClone(url, response, request, policy, cacheKey, cacheOptions) {
        if (typeof cacheOptions === 'function') {
            cacheOptions = cacheOptions(url, response, request);
        }
        let ttlOverride = cacheOptions === null || cacheOptions === void 0 ? void 0 : cacheOptions.ttl;
        if (!(ttlOverride && policy._status >= 200 && policy._status <= 299) &&
            !(request.method === 'GET' && policy.storable())) {
            return response;
        }
        let ttl = ttlOverride === undefined
            ? Math.round(policy.timeToLive() / 1000)
            : ttlOverride;
        if (ttl <= 0)
            return response;
        if (canBeRevalidated(response)) {
            ttl *= 2;
        }
        const body = await response.text();
        const entry = JSON.stringify({
            policy: policy.toObject(),
            ttlOverride,
            body,
        });
        await this.keyValueCache.set(cacheKey, entry, {
            ttl,
        });
        return new node_fetch_1.Response(body, {
            url: response.url,
            status: response.status,
            statusText: response.statusText,
            headers: Object.fromEntries(response.headers),
        });
    }
}
exports.HTTPCache = HTTPCache;
function canBeRevalidated(response) {
    return response.headers.has('ETag');
}
function policyRequestFrom(url, request) {
    var _a, _b;
    return {
        url,
        method: (_a = request.method) !== null && _a !== void 0 ? _a : 'GET',
        headers: (_b = request.headers) !== null && _b !== void 0 ? _b : {},
    };
}
function policyResponseFrom(response) {
    return {
        status: response.status,
        headers: Object.fromEntries(response.headers),
    };
}
//# sourceMappingURL=HTTPCache.js.map