"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForbiddenError = exports.AuthenticationError = exports.RESTDataSource = void 0;
const HTTPCache_1 = require("./HTTPCache");
const graphql_1 = require("graphql");
const NODE_ENV = process.env.NODE_ENV;
class RESTDataSource {
    constructor(config) {
        this.memoizedResults = new Map();
        this.memoizeGetRequests = true;
        this.httpCache = new HTTPCache_1.HTTPCache(config === null || config === void 0 ? void 0 : config.cache, config === null || config === void 0 ? void 0 : config.fetch);
    }
    cacheKeyFor(url, _request) {
        return url.toString();
    }
    resolveURL(path, _request) {
        if (path.startsWith('/')) {
            path = path.slice(1);
        }
        const baseURL = this.baseURL;
        if (baseURL) {
            const normalizedBaseURL = baseURL.endsWith('/')
                ? baseURL
                : baseURL.concat('/');
            return new URL(path, normalizedBaseURL);
        }
        else {
            return new URL(path);
        }
    }
    async didReceiveResponse(response, _request) {
        if (response.ok) {
            return this.parseBody(response);
        }
        else {
            throw await this.errorFromResponse(response);
        }
    }
    didEncounterError(error, _request) {
        throw error;
    }
    parseBody(response) {
        const contentType = response.headers.get('Content-Type');
        const contentLength = response.headers.get('Content-Length');
        if (response.status !== 204 &&
            contentLength !== '0' &&
            contentType &&
            (contentType.startsWith('application/json') ||
                contentType.endsWith('+json'))) {
            return response.json();
        }
        else {
            return response.text();
        }
    }
    async errorFromResponse(response) {
        const message = `${response.status}: ${response.statusText}`;
        let error;
        if (response.status === 401) {
            error = new AuthenticationError(message);
        }
        else if (response.status === 403) {
            error = new ForbiddenError(message);
        }
        else {
            error = new graphql_1.GraphQLError(message);
        }
        const body = await this.parseBody(response);
        Object.assign(error.extensions, {
            response: {
                url: response.url,
                status: response.status,
                statusText: response.statusText,
                body,
            },
        });
        return error;
    }
    async get(path, request) {
        return this.fetch(path, { method: 'GET', ...request });
    }
    async post(path, request) {
        return this.fetch(path, { method: 'POST', ...request });
    }
    async patch(path, request) {
        return this.fetch(path, { method: 'PATCH', ...request });
    }
    async put(path, request) {
        return this.fetch(path, { method: 'PUT', ...request });
    }
    async delete(path, request) {
        return this.fetch(path, { method: 'DELETE', ...request });
    }
    async fetch(path, request) {
        var _a;
        const modifiedRequest = {
            ...request,
            params: request.params instanceof URLSearchParams
                ? request.params
                : new URLSearchParams(request.params),
            headers: (_a = request.headers) !== null && _a !== void 0 ? _a : Object.create(null),
            body: undefined,
        };
        if (this.willSendRequest) {
            await this.willSendRequest(modifiedRequest);
        }
        const url = await this.resolveURL(path, modifiedRequest);
        for (const [name, value] of modifiedRequest.params) {
            url.searchParams.append(name, value);
        }
        if (request.body !== undefined &&
            request.body !== null &&
            (request.body.constructor === Object ||
                Array.isArray(request.body) ||
                (request.body.toJSON &&
                    typeof request.body.toJSON === 'function'))) {
            modifiedRequest.body = JSON.stringify(request.body);
            if (!modifiedRequest.headers) {
                modifiedRequest.headers = { 'content-type': 'application/json' };
            }
            else if (!modifiedRequest.headers['content-type']) {
                modifiedRequest.headers['content-type'] = 'application/json';
            }
        }
        const cacheKey = this.cacheKeyFor(url, modifiedRequest);
        const performRequest = async () => {
            return this.trace(url, modifiedRequest, async () => {
                var _a;
                const cacheOptions = modifiedRequest.cacheOptions
                    ? modifiedRequest.cacheOptions
                    : (_a = this.cacheOptionsFor) === null || _a === void 0 ? void 0 : _a.bind(this);
                try {
                    const response = await this.httpCache.fetch(url, modifiedRequest, {
                        cacheKey,
                        cacheOptions,
                    });
                    return await this.didReceiveResponse(response, modifiedRequest);
                }
                catch (error) {
                    this.didEncounterError(error, modifiedRequest);
                }
            });
        };
        if (this.memoizeGetRequests) {
            if (request.method === 'GET') {
                let promise = this.memoizedResults.get(cacheKey);
                if (promise)
                    return promise;
                promise = performRequest();
                this.memoizedResults.set(cacheKey, promise);
                return promise;
            }
            else {
                this.memoizedResults.delete(cacheKey);
                return performRequest();
            }
        }
        else {
            return performRequest();
        }
    }
    async trace(url, request, fn) {
        if (NODE_ENV === 'development') {
            const startTime = Date.now();
            try {
                return await fn();
            }
            finally {
                const duration = Date.now() - startTime;
                const label = `${request.method || 'GET'} ${url}`;
                console.log(`${label} (${duration}ms)`);
            }
        }
        else {
            return fn();
        }
    }
}
exports.RESTDataSource = RESTDataSource;
class AuthenticationError extends graphql_1.GraphQLError {
    constructor(message) {
        super(message, { extensions: { code: 'UNAUTHENTICATED' } });
        this.name = 'AuthenticationError';
    }
}
exports.AuthenticationError = AuthenticationError;
class ForbiddenError extends graphql_1.GraphQLError {
    constructor(message) {
        super(message, { extensions: { code: 'FORBIDDEN' } });
        this.name = 'ForbiddenError';
    }
}
exports.ForbiddenError = ForbiddenError;
//# sourceMappingURL=RESTDataSource.js.map