import { HTTPCache } from './HTTPCache';
import { GraphQLError } from 'graphql';
import type { KeyValueCache } from '@apollo/utils.keyvaluecache';
import type { Fetcher, FetcherRequestInit, FetcherResponse } from '@apollo/utils.fetcher';
import type { WithRequired } from '@apollo/utils.withrequired';
declare type ValueOrPromise<T> = T | Promise<T>;
declare type URLSearchParamsInit = ConstructorParameters<typeof URLSearchParams>[0];
export declare type RequestOptions = FetcherRequestInit & {
    params?: URLSearchParamsInit;
    cacheOptions?: CacheOptions | ((url: string, response: FetcherResponse, request: RequestOptions) => CacheOptions | undefined);
};
export declare type WillSendRequestOptions = Omit<WithRequired<RequestOptions, 'headers'>, 'params'> & {
    params: URLSearchParams;
};
export interface GetRequest extends RequestOptions {
    method?: 'GET';
    body?: never;
}
export interface RequestWithBody extends Omit<RequestOptions, 'body'> {
    method?: 'POST' | 'PUT' | 'PATCH' | 'DELETE';
    body?: FetcherRequestInit['body'] | object;
}
export interface CacheOptions {
    ttl?: number;
}
export interface DataSourceConfig {
    cache?: KeyValueCache;
    fetch?: Fetcher;
}
export declare abstract class RESTDataSource {
    httpCache: HTTPCache;
    memoizedResults: Map<string, Promise<any>>;
    baseURL?: string;
    memoizeGetRequests: boolean;
    constructor(config?: DataSourceConfig);
    protected cacheKeyFor(url: URL, _request: RequestOptions): string;
    protected willSendRequest?(requestOpts: WillSendRequestOptions): ValueOrPromise<void>;
    protected resolveURL(path: string, _request: RequestOptions): ValueOrPromise<URL>;
    protected cacheOptionsFor?(url: string, response: FetcherResponse, request: FetcherRequestInit): CacheOptions | undefined;
    protected didReceiveResponse<TResult = any>(response: FetcherResponse, _request: RequestOptions): Promise<TResult>;
    protected didEncounterError(error: Error, _request: RequestOptions): void;
    protected parseBody(response: FetcherResponse): Promise<object | string>;
    protected errorFromResponse(response: FetcherResponse): Promise<GraphQLError>;
    protected get<TResult = any>(path: string, request?: GetRequest): Promise<TResult>;
    protected post<TResult = any>(path: string, request?: RequestWithBody): Promise<TResult>;
    protected patch<TResult = any>(path: string, request?: RequestWithBody): Promise<TResult>;
    protected put<TResult = any>(path: string, request?: RequestWithBody): Promise<TResult>;
    protected delete<TResult = any>(path: string, request?: RequestWithBody): Promise<TResult>;
    private fetch;
    protected trace<TResult>(url: URL, request: RequestOptions, fn: () => Promise<TResult>): Promise<TResult>;
}
export declare class AuthenticationError extends GraphQLError {
    constructor(message: string);
}
export declare class ForbiddenError extends GraphQLError {
    constructor(message: string);
}
export {};
//# sourceMappingURL=RESTDataSource.d.ts.map